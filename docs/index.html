<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabric Prompt Library</title>
    
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5; /* Light gray background */
            color: #1c1e21; /* Dark gray text */
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #ffffff; /* White content background */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #1877f2; /* Blue heading */
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #e4e6eb; /* Light border */
            padding-bottom: 15px;
        }
        h2 {
            color: #3578e5; /* Darker blue for subheadings */
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ccd0d5; /* Lighter border for H2 */
            padding-bottom: 8px;
        }
        h3 {
            color: #1c1e21; /* Dark gray for sub-subheadings */
            margin-top: 20px;
            margin-bottom: 10px;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            margin-bottom: 12px;
            padding: 12px;
            background-color: #e7f3ff; /* Light blue list item background */
            border-radius: 6px;
            border: 1px solid #cce0ff; /* Lighter blue border */
        }
        li a {
            text-decoration: none;
            color: #05386b; /* Dark blue link */
            font-weight: 500;
        }
        li a:hover {
            text-decoration: underline;
            color: #0056b3; /* Darker blue on hover */
        }
        p.intro, p.usage-intro {
            text-align: center;
            color: #606770; /* Medium gray for intro text */
            margin-bottom: 20px;
        }
        .toc { /* Table of Contents specific styling */
            margin-bottom: 30px;
            padding: 15px;
            background-color: #e9ecef; /* Very light gray for TOC background */
            border-radius: 6px;
        }
        .toc h2 {
            text-align: left;
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #333;
        }
        .toc ul {
            margin-left: 20px;
        }
        .toc a {
            color: #007bff;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        /* Loader and Error Message Styles */
        #loader {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }
        #error-message {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #dc3545;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #error-message h3 {
            margin-top: 0;
            color: #dc3545;
        }
        #error-message p {
            margin: 5px 0 0;
            color: #333;
        }
        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s ease;
            opacity: 0;
            z-index: 1000;
        }
        #toast.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="app" class="container mx-auto">
        <div class="toc" id="table-of-contents">
            <h2 class="text-xl font-bold mb-4">Table of Contents</h2>
            <ul>
                <!-- Dynamic TOC will be inserted here -->
            </ul>
        </div>
        <h1 class="text-3xl font-extrabold mb-6">Fabric Prompt Library</h1>
        <p class="intro text-lg mb-4">A curated collection of prompts to supercharge your creative projects.</p>
        
        <div class="mb-6">
            <input type="text" id="promptSearchInput" placeholder="Search prompts..." class="w-full p-3 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>

        <div id="loader" class="flex items-center justify-center">
            <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v16a8 8 0 01-8-8z"></path>
            </svg>
        </div>

        <div id="error-message" class="hidden">
            <div class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg" role="alert">
                <div class="flex">
                    <div class="py-1">
                        <svg class="w-5 h-5 text-red-500 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <path stroke="currentColor" stroke-width="2" d="M12 8v4m0 4h.01M12 4a8 8 0 100 16 8 8 0 000-16z"></path>
                        </svg>
                    </div>
                    <div>
                        <h3 class="font-bold text-red-300 mb-1">Error</h3>
                        <p id="error-text" class="text-red-300 text-sm"></p>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 gap-4" id="prompt-list">
            <!-- Prompts will be dynamically inserted here -->
        </div>
    </div>
    <div id="toast" class="fixed bottom-5 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-xl transition-opacity duration-300 opacity-0 z-50"></div>

    <script>
        // --- Configuration ---
        const INDEX_MD_PATH = 'index.md'; // Path to your index.md file
        let allPrompts = [];
        let rawMdContent = ''; // To store the raw content of index.md

        // --- DOM Elements ---
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const promptListContainer = document.getElementById('prompt-list');
        const searchInput = document.getElementById('promptSearchInput');
        const toast = document.getElementById('toast');

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', fetchAndDisplayPrompts);
        searchInput.addEventListener('input', handleSearch);

        promptListContainer.addEventListener('click', function(event) {
            const toggleButton = event.target.closest('.toggle-button');
            const copyButton = event.target.closest('.copy-button');
            
            if (toggleButton) {
                togglePrompt(toggleButton);
            }
            if (copyButton) {
                 event.stopPropagation(); // Prevent toggle when copy is clicked
                 copyPrompt(copyButton);
            }
        });

        // --- Core Fetching and Parsing Logic ---
        async function fetchAndDisplayPrompts() {
            loader.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            try {
                const response = await fetch(INDEX_MD_PATH);
                if (!response.ok) throw new Error(`Failed to fetch ${INDEX_MD_PATH}. Ensure it's accessible.`);
                rawMdContent = await response.text();
                
                allPrompts = parseMarkdown(rawMdContent);

                if (allPrompts.length === 0) {
                    showError("No prompts found in index.md or failed to parse.");
                    return;
                }

                allPrompts.sort((a, b) => a.title.localeCompare(b.title));
                renderPrompts(allPrompts);

            } catch (error) {
                console.error("Error fetching or parsing prompts:", error);
                showError(error.message + " Check console for more details. If using file://, try a local server.");
            } finally {
                loader.classList.add('hidden');
            }
        }

        function parseMarkdown(markdownContent) {
            const prompts = [];
            const lines = markdownContent.split('\\n');
            let currentCategory = "General";
            let categoryId = 0;

            lines.forEach(line => {
                const categoryMatch = line.match(/^##\\s+(.*)/);
                if (categoryMatch) {
                    currentCategory = categoryMatch[1].trim();
                    categoryId++;
                    return;
                }

                const promptMatch = line.match(/^-\s+\[([^\]]+)\]\(([^)]+)\)/);
                if (promptMatch) {
                    const title = promptMatch[1].trim();
                    const filePath = promptMatch[2].trim();
                    // Create a unique ID based on category and title
                    const id = `${currentCategory.replace(/\\s+/g, '-')}-${title.replace(/\\s+/g, '-')}-${prompts.length}`;
                    prompts.push({
                        id: id,
                        sourceName: currentCategory, // Using category as sourceName for consistency with original example
                        title: title,
                        content: null, // Will be fetched on demand
                        description: `A prompt from the '${currentCategory}' category.`,
                        filePath: filePath,
                        category: currentCategory
                    });
                }
            });
            return prompts;
        }
        
        async function fetchPromptContent(prompt) {
            if (prompt.content) return prompt.content; // Already fetched

            try {
                // Adjust path if necessary, assuming fabric_ui_shell.html is in 'fabric/'
                // and paths in index.md are relative to the 'fabric/' directory.
                // If index.md paths are relative to workspace root, this might need adjustment.
                const response = await fetch(prompt.filePath); 
                if (!response.ok) {
                    console.error(`Failed to fetch content for ${prompt.title} from ${prompt.filePath}`);
                    return "Error: Could not load prompt content.";
                }
                const textContent = await response.text();
                prompt.content = textContent; // Cache the content
                return textContent;
            } catch (error) {
                console.error(`Error fetching prompt content for ${prompt.title}:`, error);
                return "Error: Could not load prompt content due to a network or parsing issue.";
            }
        }


        // --- UI Rendering and Interaction ---
        function renderPrompts(promptsToRender) {
            promptListContainer.innerHTML = '';
            if (promptsToRender.length === 0) {
                promptListContainer.innerHTML = `<p class="text-center text-[var(--ui-subdued-blue)]">No prompts match your search.</p>`;
                return;
            }
            promptsToRender.forEach((prompt, index) => {
                const promptElement = document.createElement('div');
                promptElement.className = 'prompt-container group/prompt bg-[var(--ui-dark-grey)] bg-opacity-70 rounded-lg shadow-md border border-[var(--ui-subdued-blue)] hover:border-[var(--accent-orange)] hover:shadow-xl transition-all duration-300 ease-in-out';
                promptElement.dataset.promptId = prompt.id;
                
                promptElement.innerHTML = `
                    <div class="flex items-center gap-4 px-6 py-4 cursor-pointer toggle-button">
                        <div class="flex-grow">
                            <div class="flex items-center gap-3">
                                <p class="text-[var(--text-white)] text-base font-semibold leading-normal">${index + 1}. ${escapeHtml(prompt.title)}</p>
                                <span class="text-xs bg-gray-600 text-gray-300 px-2 py-1 rounded-full whitespace-nowrap">${escapeHtml(prompt.category)}</span>
                            </div>
                            <p class="text-[var(--ui-subdued-blue)] text-sm font-normal leading-normal line-clamp-1 group-hover/prompt:line-clamp-none transition-all">${escapeHtml(prompt.description)}</p>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="copy-button flex items-center justify-center gap-1 rounded-md h-9 w-9 p-0 bg-transparent text-[var(--ui-subdued-blue)] hover:bg-[var(--accent-orange)] hover:text-[var(--text-white)] transition-colors" title="Copy Full Prompt (loads content first)">
                                <span class="material-icons icon !text-lg">content_copy</span>
                            </button>
                            <button class="toggle-button flex items-center justify-center gap-1 rounded-md h-9 px-3 bg-[var(--ui-subdued-blue)] text-[var(--text-white)] text-xs font-medium hover:bg-[var(--accent-orange)] transition-colors">
                                <span class="truncate">View</span>
                                <span class="material-icons icon !text-lg transition-transform duration-300 group-data-[open=true]/prompt:rotate-180">expand_more</span>
                            </button>
                        </div>
                    </div>
                    <div class="details-content hidden h-0 overflow-hidden transition-all duration-300 ease-in-out data-[open=true]:h-auto data-[open=true]:py-4 data-[open=true]:px-6 border-t border-[var(--ui-subdued-blue)]">
                        <div class="prompt-content-loader text-center p-4 text-[var(--ui-subdued-blue)]">Loading content...</div>
                        <pre class="prompt-text-display text-[var(--ui-subdued-blue)] text-sm mb-4 whitespace-pre-wrap font-mono hidden"></pre>
                        <button class="copy-button-details flex items-center justify-center gap-2 rounded-md h-9 px-4 bg-[var(--accent-orange)] text-white text-sm font-medium hover:bg-opacity-90 transition-colors hidden">
                            <span class="material-icons icon !text-base">content_copy</span>
                            <span class="truncate">Copy Full Prompt</span>
                        </button>
                    </div>
                `;
                promptListContainer.appendChild(promptElement);
            });
        }

        async function togglePrompt(button) {
            const promptContainer = button.closest('.prompt-container');
            const contentDiv = promptContainer.querySelector('.details-content');
            const isOpen = contentDiv.dataset.open === 'true';
            
            contentDiv.dataset.open = !isOpen;
            promptContainer.dataset.open = !isOpen;

            if (!isOpen) { // If opening
                const promptId = promptContainer.dataset.promptId;
                const prompt = allPrompts.find(p => p.id === promptId);
                if (!prompt) return;

                const loaderElement = contentDiv.querySelector('.prompt-content-loader');
                const textDisplayElement = contentDiv.querySelector('.prompt-text-display');
                const copyDetailsButton = contentDiv.querySelector('.copy-button-details');

                if (!prompt.content) { // Content not yet fetched
                    loaderElement.classList.remove('hidden');
                    textDisplayElement.classList.add('hidden');
                    copyDetailsButton.classList.add('hidden');

                    const fetchedContent = await fetchPromptContent(prompt);
                    textDisplayElement.textContent = fetchedContent;
                    
                    loaderElement.classList.add('hidden');
                    textDisplayElement.classList.remove('hidden');
                    if (fetchedContent && !fetchedContent.startsWith("Error:")) {
                        copyDetailsButton.classList.remove('hidden');
                    }
                } else { // Content already fetched
                    textDisplayElement.textContent = prompt.content;
                    loaderElement.classList.add('hidden');
                    textDisplayElement.classList.remove('hidden');
                     if (prompt.content && !prompt.content.startsWith("Error:")) {
                        copyDetailsButton.classList.remove('hidden');
                    }
                }
            }
        }

        async function copyPrompt(button) {
            const promptContainer = button.closest('.prompt-container');
            const promptId = promptContainer.dataset.promptId;
            const prompt = allPrompts.find(p => p.id === promptId);
            if (!prompt) return;

            let contentToCopy = prompt.content;
            if (!contentToCopy) { // If content not loaded yet (e.g. main card copy button)
                showToast('Loading content to copy...');
                contentToCopy = await fetchPromptContent(prompt);
                 // Update the details view if it happens to be open
                const contentDiv = promptContainer.querySelector('.details-content');
                if (contentDiv && contentDiv.dataset.open === 'true') {
                    const textDisplayElement = contentDiv.querySelector('.prompt-text-display');
                    textDisplayElement.textContent = contentToCopy;
                    contentDiv.querySelector('.prompt-content-loader').classList.add('hidden');
                    textDisplayElement.classList.remove('hidden');
                    if (contentToCopy && !contentToCopy.startsWith("Error:")) {
                         contentDiv.querySelector('.copy-button-details').classList.remove('hidden');
                    }
                }
            }
            
            if (contentToCopy && !contentToCopy.startsWith("Error:")) {
                navigator.clipboard.writeText(contentToCopy).then(() => {
                    showToast('Prompt copied!');
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    showToast('Copy failed! See console.');
                });
            } else {
                showToast('Error: Content not available to copy.');
            }
        }

        function handleSearch() {
            const searchTerm = searchInput.value.toLowerCase();
            const filteredPrompts = allPrompts.filter(prompt => {
                const title = prompt.title.toLowerCase();
                const category = prompt.category.toLowerCase();
                // Basic content search if content is already loaded (optional, can be slow if many prompts are open)
                // const content = prompt.content ? prompt.content.toLowerCase() : ""; 
                return title.includes(searchTerm) || category.includes(searchTerm); // || content.includes(searchTerm);
            });
            renderPrompts(filteredPrompts);
        }
        
        function showError(message) {
            errorMessage.classList.remove('hidden');
            errorText.textContent = message;
        }
        
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.remove('opacity-0');
            setTimeout(() => {
                toast.classList.add('opacity-0');
            }, 2000);
        }
    </script>
</body>
</html>
<!--
    This HTML file serves as the main entry point for the Fabric Prompt Library.
    It fetches prompts from index.md, displays them, and allows users to search and copy prompts.
    The design is responsive and uses Tailwind CSS for styling.

-->